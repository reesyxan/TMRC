---
title: "TMRC3 ML Exploration"
author: "Theresa Alexander"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


# load the package
library(VGAM)
library(openxlsx)
library(ggplot2)
library(stringr)
library(caTools)
library(scran)
library(scater)
library(gridExtra)
library(grid)
```

```{r}
normed_tmrc <- read.csv("~/Desktop/ElSayedLab/TMRC/tmrc_v202011.csv")
tmrc_metadata <- read.xlsx("~/Desktop/ElSayedLab/TMRC/TMRC_metadata.xlsx", rowNames = TRUE)

#subset to keep only samples with clinical outcome recorded
tmrc_clinicaloutcomesamples <- subset(tmrc_metadata, !is.na(clinicaloutcome) & clinicaloutcome != "lost")
normed_tmrc_clinicaloutcomes <- normed_tmrc[,tolower(rownames(tmrc_clinicaloutcomesamples))]
rownames(normed_tmrc_clinicaloutcomes) <- normed_tmrc$row.names

#subset first timepoint samples
timepoint <- str_sub(tmrc_clinicaloutcomesamples$samplename, -1)
#tmrc_firsttimepointsamples <- tmrc_clinicaloutcomesamples[str_sub(tmrc_clinicaloutcomesamples$samplename, -1) == 1,]

CellType <- tmrc_clinicaloutcomesamples$typeofcells
```

# PCA on all samples
```{r}
PCA_normedtmrc <- prcomp(normed_tmrc_clinicaloutcomes)

ggplot(as.data.frame(PCA_normedtmrc$rotation), aes(x = PC1, y = PC2, col = timepoint)) + 
  geom_point() +
  theme_classic() 

ggplot(as.data.frame(PCA_normedtmrc$rotation), aes(x = PC1, y = PC2, col = CellType)) + 
  geom_point() +
  theme_classic()


```
Points don't offer a lot of variation based on timepoint, but do based on cell type. We'll take this non-separation by timepoint in the PCA as evidence that we can (for now) use all timepoints just to see what kind of predictive power we have with more samples.



# Split into Test and Train
```{r}
#create a list of random number ranging from 1 to number of rows from actual data and 70% of the data into training data  
set.seed(1234)
train_indices <- sort(sample(nrow(t(normed_tmrc_clinicaloutcomes)), nrow(t(normed_tmrc_clinicaloutcomes))*.8))

#creating training data set by selecting the output row values
train <- t(normed_tmrc_clinicaloutcomes)[train_indices,]

#creating test data set by not selecting the output row values
test <- t(normed_tmrc_clinicaloutcomes)[-train_indices,]


target_train <- tmrc_clinicaloutcomesamples$clinicaloutcome[train_indices]
target_train_binary <- ifelse(target_train =="cure", 1, 0)
target_test <- tmrc_clinicaloutcomesamples$clinicaloutcome[-train_indices]
```

# Look at Highly Variable Genes of Training Data
```{r}
#subset highly variable genes
stats <- scran::modelGeneVar(as.matrix(t(train)))
var.features <- scran::getTopHVGs(stats, n = 10)

train_varfeatures <- train[,var.features]
celltype <- tmrc_clinicaloutcomesamples[train_indices,]$typeofcells
timepoint2 <- timepoint[train_indices]

boxplot(train_varfeatures[,1] ~ celltype)
boxplot(train_varfeatures[,2] ~ celltype)
boxplot(train_varfeatures[,3] ~ celltype)


boxplot(train_varfeatures[,1] ~ target_train)
boxplot(train_varfeatures[,2] ~ target_train)
boxplot(train_varfeatures[,3] ~ target_train)

```
As expected based on the PCA plot, all the HVG's give us are genes which are variable wrt cell type and not cure/fail, so these aren't going to help us predict outcome. We will do DE for the condition outcome to get a list of genes to use in the model.


# DE
```{r}
library(DESeq2)
#read in raw reads
rawreads <- read.xlsx("~/Desktop/ElSayedLab/TMRC/tmrc_rawreads.xlsx", rowNames = TRUE)
rawreads_train <- rawreads[,rownames(train)]

coldata <- data.frame(row.names = rownames(train), outcome = as.factor(target_train))

dds <- DESeqDataSetFromMatrix(countData = rawreads_train, 
                              colData = coldata, 
                              design = ~ outcome)

dds$outcome <- relevel(dds$outcome, ref = "failure")

dds <- dds[rownames(normed_tmrc_clinicaloutcomes),]


dds <- DESeq(dds)
res <- results(dds)
resOrdered <- res[order(res$pvalue),]

message(paste("There are ", sum(res$padj < 0.05 & res$log2FoldChange > 1, na.rm=TRUE), " genes with adjusted p-value < .05 and log2FC > 1"))
```


```{r}
res05 <- results(dds, alpha=0.05)

top25DEgenes_up <- rownames(res05[order(res05$log2FoldChange, decreasing = TRUE),][1:25,])
top25DEgenes_down <- rownames(res05[order(res05$log2FoldChange),][1:25,])
top50DEgenes_updown <- rownames(res05[order(abs(res05$log2FoldChange), decreasing = TRUE),][1:50,])

```

## Boxplots for top DE genes
```{r}
boxplot(train[,top50DEgenes_updown[1]] ~ target_train, ylab = top50DEgenes_updown[1], xlab = "")
boxplot(train[,top50DEgenes_updown[2]] ~ target_train, ylab = top50DEgenes_updown[2], xlab = "")
boxplot(train[,top50DEgenes_updown[3]] ~ target_train, ylab = top50DEgenes_updown[3], xlab = "")


message(paste("There are", sum(top25DEgenes_down %in% top50DEgenes_updown, 25-sum(top25DEgenes_up %in% top50DEgenes_updown)), "down regulated genes and", 50 - sum(top25DEgenes_down %in% top50DEgenes_updown, 25-sum(top25DEgenes_up %in% top50DEgenes_updown)), "upregulated genes in the top 50 DE genes."))
```


# Logistic Regression Model
```{r}
train_DEfeatures <- as.data.frame(train[,top50DEgenes[1:50]])

fit_1var <- glm(target_train ~ train[,top50DEgenes[1]], family=binomial, data= data.frame(train[,top50DEgenes[1]]))
fit_2vars <- glm(target_train ~ train[,top50DEgenes[2]], family=binomial, data= data.frame(train[,top50DEgenes[2]]))
fit_3vars <- glm(target_train ~ train[,top50DEgenes[3]], family=binomial, data= data.frame(train[,top50DEgenes[3]]))

summary(fit_1var)
summary(fit_2vars)
summary(fit_3vars)

probabilities_1var <- predict(fit_1var, as.data.frame(train_varfeatures)[,1:3], type="response")
probabilities_2var <- predict(fit_2vars, as.data.frame(train_varfeatures)[,1:3], type="response")
probabilities_3var <- predict(fit_3vars, as.data.frame(train_varfeatures)[,1:3], type="response")

hist(probabilities_1var)
hist(probabilities_2var)
hist(probabilities_3var)
```


## Backard Stepwise Regression
```{r}
#full model

fit_full <- glm(target_train_binary ~ ENSG00000282278 + ENSG00000273734 + ENSG00000204577 + ENSG00000266086, family=binomial, data= train_DEfeatures)

#backward stepwise regression (suppressing output with trace = 0)
backwards <- step(fit_full, trace = 0) 

writeLines("The optimal model using backward stepwise regression with the first top 4 DE genes is:\n")
formula(backwards)

writeLines("\nwith AIC = ")
backwards$aic
```


## Forward Stepwise Regression
```{r}
fit_0 <- glm(target_train_binary ~ 1, family=binomial, data = train_DEfeatures)
forwards = step(fit_0, scope=list(lower=formula(fit_0), upper=formula(fit_full)), direction="forward", trace = 0)

writeLines("The optimal model using backward stepwise regression with the first top 4 DE genes is: \n")
formula(forwards)

writeLines("\nwith AIC = ")
forwards$aic

writeLines("\nSo the forwards and backwards stepwise models agree that of the top 4 DE genes, ENSG00000204577 + ENSG00000282278 should be included in the model.")
```


## Stepwise Both directions
```{r}
bothways <- step(fit_0, list(lower=formula(fit_0), upper=formula(fit_full)), direction="both", trace=0)

writeLines("The formula using both ways stepwise regression finds the same model as well: \n ")
formula(bothways)

writeLines("\nwith AIC = ")
bothways$aic
```

## Just for fun... picking 4 random genes from top 50 gene lines
```{r}
set.seed(11)
randomgenes <- sample(1:50, 4)

randomgenessubset <- as.data.frame(train_DEfeatures[,randomgenes])

fit_random <- glm(target_train_binary ~ randomgenessubset[,1] + randomgenessubset[,2] + randomgenessubset[,3] + randomgenessubset[,4], family=binomial, data= randomgenessubset)

#backward stepwise regression (suppressing output with trace = 0)
random <- step(fit_random, trace = 0) 

writeLines("The optimal model using random 4 genes and backwards stepwise regression is:\n")
formula(random)

writeLines("\nwith AIC = ")
random$aic

writeLines("So even with a random set of 4 genes from the top DE gene list, the AIC is comparable, meaning the model is still pretty comparable")

```

## Let's bootstrap that
```{r}
AICs <- c()
models <- data.frame(row.names = c("gene1", "gene2", "gene3", "gene4"))
for (i in 1:100){
  randomgenes <- sample(1:50, 4)
  randomgenessubset <- as.data.frame(train_DEfeatures[,randomgenes])
  fit_random <- trycatch(glm(target_train_binary ~ randomgenessubset[,1] + randomgenessubset[,2] + randomgenessubset[,3] + randomgenessubset[,4],
                    family=binomial, 
                    data= randomgenessubset))
  #backward stepwise regression (suppressing output with trace = 0)
  random <- step(fit_random, trace = 0) 
  models <- cbind(models, randomgenes)
  AICs <- c(AICs, random$aic)
}

hist(AICs)

randomgenessubset <- as.data.frame(train_DEfeatures[,models[,9]])
  fit_random <- glm(target_train_binary ~ randomgenessubset[,1] + randomgenessubset[,2] + randomgenessubset[,3] + randomgenessubset[,4],
                    family=binomial, 
                    data= randomgenessubset)
  #backward stepwise regression (suppressing output with trace = 0)
  random <- step(fit_random, trace = 0) 
random$aic
```

```{r, include = FALSE}
#probabilities <- predict(fit_1var, as.data.frame(train_varfeatures)[,1:4], type="response")
#predictions <- apply(probabilities, 1, which.max)
#predictions[which(predictions=="1")] <- levels(iris$Species)[1]
#predictions[which(predictions=="2")] <- levels(iris$Species)[2]
#predictions[which(predictions=="3")] <- levels(iris$Species)[3]


```

